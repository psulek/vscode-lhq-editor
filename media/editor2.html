<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="lodash.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
        }

        div {
            margin-bottom: 10px;
        }

        label {
            display: block;
            margin-bottom: 5px;
        }

        input,
        textarea,
        select {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
        }
    </style>
</head>

<body>
    <div id="app">
        <div>
            <label for="name">Name:</label>
            <input type="text" id="name" :value="item.name" @input="fns.onNameChanged">
        </div>
        <div>
            <label for="description">Description:</label>
            <textarea id="description" :value="item.description" @input="fns.onDescriptionChanged" rows="5"></textarea>
        </div>
        <div>
            <label for="state">State:</label>
            <select id="state" :value="item.state" @change="fns.onStateChanged">
                <option disabled value="">Please select one</option>
                <option>New</option>
                <option>Edited</option>
                <option>NeedsReview</option>
                <option>Final</option>
            </select>
        </div>
    </div>

    <script>
        // debugger;
        const { createApp, ref, watch } = Vue;
        const debounceOpts = {
            leading: false,
            trailing: true
        };
        const debounceWait = 500;

        createApp({
            data() {
                return {
                    item: {
                        name: 'item1',
                        description: 'desc1',
                        state: 'New'
                    },
                    fns: {
                        onNameChanged: null,
                        onDescriptionChanged: null,
                        onStateChanged: null
                    }
                }
            },

            created() {
                this.fns.onNameChanged = _.debounce(this.onNameChanged, debounceWait, debounceOpts);
                this.fns.onDescriptionChanged = _.debounce(this.onDescriptionChanged, debounceWait, debounceOpts);
                this.fns.onStateChanged = _.debounce(this.onStateChanged, debounceWait, debounceOpts);
            },

            unmounted() {
                // also a good idea to cancel the timer
                // when the component is removed
                // this.debouncedClick.cancel()
                for (const fn in this.fns) {
                    if (typeof this.fns[fn] === 'function' && this.fns[fn].cancel) {
                        this.fns[fn].cancel();
                    }
                }
            },

            methods: {
                onNameChanged() {
                    console.log('Name changed:', this.item.name);
                },
                onDescriptionChanged() {
                    console.log('Description changed:', this.item.description);
                },
                onStateChanged() {
                    console.log('State changed:', this.item.state);
                }
            }


            // setup() {
            //     const item = ref({
            //         name: '',
            //         description: '',
            //         state: 'New'
            //     })

            //     // In a real VS Code extension, you would use acquireVsCodeApi
            //     // to communicate with the extension and get/set the data.
            //     // const vscode = acquireVsCodeApi();
            //     //
            //     // Example of receiving data from the extension:
            //     // window.addEventListener('message', event => {
            //     //     const message = event.data;
            //     //     if (message.command === 'updateData') {
            //     //         item.value = message.data;
            //     //     }
            //     // });
            //     //
            //     // To send data back to the extension:
            //     // function updateData() {
            //     //     vscode.postMessage({
            //     //         command: 'updateData',
            //     //         data: item.value
            //     //     });
            //     // }
            //     // You would call updateData() whenever a value changes,
            //     watch(item, (newValue) => {
            //         updateData(newValue);
            //     }, { deep: false });
            //     // perhaps by watching the 'item' ref.


            //     function updateData(data) {
            //         // Example function to send data back to the extension
            //         console.log('Data updated:', data);
            //         // vscode.postMessage({
            //         //     command: 'updateData',
            //         //     data: data
            //         // });
            //     }

            //     return {
            //         item
            //     }
            // }
        }).mount('#app')
    </script>
</body>

</html>